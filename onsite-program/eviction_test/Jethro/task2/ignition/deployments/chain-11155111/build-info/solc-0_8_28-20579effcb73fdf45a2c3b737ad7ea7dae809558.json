{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-20579effcb73fdf45a2c3b737ad7ea7dae809558",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/LudoGame.sol": "project/contracts/LudoGame.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/LudoGame.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title LudoGame Smart Contract\n * @dev A decentralized Ludo game where users can register, stake tokens, and play\n * @author Jethro - Web3bridge Cohort XIII\n */\ncontract LudoGame {\n    // Game constants\n    uint256 public constant STAKE_AMOUNT = 0.01 ether;\n    uint256 public constant MAX_PLAYERS = 4;\n    uint256 public constant BOARD_SIZE = 52;\n    \n    // Player colors\n    enum Color { RED, GREEN, BLUE, YELLOW }\n    \n    // Game states\n    enum GameState { WAITING, ACTIVE, FINISHED }\n    \n    // Player structure\n    struct Player {\n        address playerAddress;\n        string name;\n        Color color;\n        uint256 position;\n        bool isRegistered;\n        bool hasStaked;\n        uint256 score;\n    }\n    \n    // Game structure\n    struct Game {\n        uint256 gameId;\n        Player[MAX_PLAYERS] players;\n        uint256 playerCount;\n        GameState state;\n        uint256 currentTurn;\n        uint256 prizePool;\n        address winner;\n        uint256 createdAt;\n    }\n    \n    // State variables\n    mapping(uint256 => Game) public games;\n    mapping(address => uint256) public playerToGame;\n    mapping(address => bool) public registeredPlayers;\n    mapping(address => string) public playerNames;\n    mapping(address => Color) public playerColors;\n    mapping(address => uint256) public playerScores;\n    \n    uint256 public gameCounter;\n    uint256 public totalStaked;\n    \n    // Events\n    event PlayerRegistered(address indexed player, string name, Color color);\n    event GameCreated(uint256 indexed gameId, address indexed creator);\n    event PlayerJoinedGame(uint256 indexed gameId, address indexed player, Color color);\n    event GameStarted(uint256 indexed gameId, uint256 playerCount);\n    event DiceRolled(uint256 indexed gameId, address indexed player, uint256 diceValue);\n    event PlayerMoved(uint256 indexed gameId, address indexed player, uint256 newPosition);\n    event GameFinished(uint256 indexed gameId, address indexed winner, uint256 prizeAmount);\n    event TokensStaked(address indexed player, uint256 amount);\n    \n    // Modifiers\n    modifier onlyRegistered() {\n        require(registeredPlayers[msg.sender], \"Player not registered\");\n        _;\n    }\n    \n    modifier gameExists(uint256 _gameId) {\n        require(_gameId < gameCounter, \"Game does not exist\");\n        _;\n    }\n    \n    modifier gameActive(uint256 _gameId) {\n        require(games[_gameId].state == GameState.ACTIVE, \"Game is not active\");\n        _;\n    }\n    \n    modifier playerTurn(uint256 _gameId) {\n        Game storage game = games[_gameId];\n        require(\n            game.players[game.currentTurn].playerAddress == msg.sender,\n            \"Not your turn\"\n        );\n        _;\n    }\n    \n    modifier correctStake() {\n        require(msg.value == STAKE_AMOUNT, \"Incorrect stake amount\");\n        _;\n    }\n    \n    /**\n     * @dev Register a new player with name and color\n     * @param _name Player's name\n     * @param _color Player's chosen color (0=RED, 1=GREEN, 2=BLUE, 3=YELLOW)\n     */\n    function registerPlayer(string memory _name, uint8 _color) external {\n        require(!registeredPlayers[msg.sender], \"Player already registered\");\n        require(_color < 4, \"Invalid color\");\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\n        \n        registeredPlayers[msg.sender] = true;\n        playerNames[msg.sender] = _name;\n        playerColors[msg.sender] = Color(_color);\n        \n        emit PlayerRegistered(msg.sender, _name, Color(_color));\n    }\n    \n    /**\n     * @dev Create a new game\n     */\n    function createGame() external onlyRegistered returns (uint256) {\n        require(playerToGame[msg.sender] == 0 || games[playerToGame[msg.sender]].state == GameState.FINISHED, \n                \"Player already in active game\");\n        \n        uint256 gameId = gameCounter++;\n        Game storage newGame = games[gameId];\n        \n        newGame.gameId = gameId;\n        newGame.playerCount = 0;\n        newGame.state = GameState.WAITING;\n        newGame.currentTurn = 0;\n        newGame.prizePool = 0;\n        newGame.createdAt = block.timestamp;\n        \n        emit GameCreated(gameId, msg.sender);\n        return gameId;\n    }\n    \n    /**\n     * @dev Join an existing game with stake\n     * @param _gameId The game ID to join\n     */\n    function joinGame(uint256 _gameId) \n        external \n        payable \n        onlyRegistered \n        gameExists(_gameId) \n        correctStake \n    {\n        Game storage game = games[_gameId];\n        require(game.state == GameState.WAITING, \"Game not accepting players\");\n        require(game.playerCount < MAX_PLAYERS, \"Game is full\");\n        require(playerToGame[msg.sender] == 0 || games[playerToGame[msg.sender]].state == GameState.FINISHED, \n                \"Player already in active game\");\n        \n        // Check if color is already taken\n        Color playerColor = playerColors[msg.sender];\n        for (uint256 i = 0; i < game.playerCount; i++) {\n            require(game.players[i].color != playerColor, \"Color already taken\");\n        }\n        \n        // Add player to game\n        Player storage newPlayer = game.players[game.playerCount];\n        newPlayer.playerAddress = msg.sender;\n        newPlayer.name = playerNames[msg.sender];\n        newPlayer.color = playerColor;\n        newPlayer.position = 0;\n        newPlayer.isRegistered = true;\n        newPlayer.hasStaked = true;\n        newPlayer.score = 0;\n        \n        game.playerCount++;\n        game.prizePool += msg.value;\n        playerToGame[msg.sender] = _gameId;\n        totalStaked += msg.value;\n        \n        emit PlayerJoinedGame(_gameId, msg.sender, playerColor);\n        emit TokensStaked(msg.sender, msg.value);\n        \n        // Start game if we have 4 players\n        if (game.playerCount == MAX_PLAYERS) {\n            game.state = GameState.ACTIVE;\n            emit GameStarted(_gameId, game.playerCount);\n        }\n    }\n    \n    /**\n     * @dev Roll dice and move player\n     * @param _gameId The game ID\n     */\n    function rollDiceAndMove(uint256 _gameId) \n        external \n        gameExists(_gameId) \n        gameActive(_gameId) \n        playerTurn(_gameId) \n    {\n        Game storage game = games[_gameId];\n        \n        // Generate dice roll (1-6)\n        uint256 diceValue = _rollDice();\n        \n        emit DiceRolled(_gameId, msg.sender, diceValue);\n        \n        // Move player\n        Player storage currentPlayer = game.players[game.currentTurn];\n        uint256 newPosition = currentPlayer.position + diceValue;\n        \n        // Handle board wrap-around\n        if (newPosition >= BOARD_SIZE) {\n            newPosition = newPosition - BOARD_SIZE;\n            currentPlayer.score += 10; // Bonus for completing a lap\n        }\n        \n        currentPlayer.position = newPosition;\n        currentPlayer.score += diceValue;\n        \n        emit PlayerMoved(_gameId, msg.sender, newPosition);\n        \n        // Check for win condition (simplified: first to complete 3 laps)\n        if (currentPlayer.score >= 150) {\n            _finishGame(_gameId, msg.sender);\n            return;\n        }\n        \n        // Move to next player's turn\n        game.currentTurn = (game.currentTurn + 1) % game.playerCount;\n    }\n    \n    /**\n     * @dev Internal function to generate dice roll\n     * @return Random number between 1 and 6\n     */\n    function _rollDice() private view returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(\n            block.timestamp,\n            block.prevrandao,\n            msg.sender,\n            block.number\n        ))) % 6) + 1;\n    }\n    \n    /**\n     * @dev Internal function to finish game and distribute prize\n     * @param _gameId The game ID\n     * @param _winner The winner's address\n     */\n    function _finishGame(uint256 _gameId, address _winner) private {\n        Game storage game = games[_gameId];\n        game.state = GameState.FINISHED;\n        game.winner = _winner;\n        \n        uint256 prizeAmount = game.prizePool;\n        game.prizePool = 0;\n        \n        // Update winner's total score\n        playerScores[_winner] += 100; // Bonus for winning\n        \n        // Transfer prize to winner\n        (bool success, ) = payable(_winner).call{value: prizeAmount}(\"\");\n        require(success, \"Prize transfer failed\");\n        \n        emit GameFinished(_gameId, _winner, prizeAmount);\n    }\n    \n    /**\n     * @dev Get game information\n     * @param _gameId The game ID\n     */\n    function getGameInfo(uint256 _gameId) \n        external \n        view \n        gameExists(_gameId) \n        returns (\n            uint256 gameId,\n            uint256 playerCount,\n            GameState state,\n            uint256 currentTurn,\n            uint256 prizePool,\n            address winner\n        ) \n    {\n        Game storage game = games[_gameId];\n        return (\n            game.gameId,\n            game.playerCount,\n            game.state,\n            game.currentTurn,\n            game.prizePool,\n            game.winner\n        );\n    }\n    \n    /**\n     * @dev Get player information in a game\n     * @param _gameId The game ID\n     * @param _playerIndex The player index (0-3)\n     */\n    function getPlayerInGame(uint256 _gameId, uint256 _playerIndex) \n        external \n        view \n        gameExists(_gameId) \n        returns (\n            address playerAddress,\n            string memory name,\n            Color color,\n            uint256 position,\n            uint256 score\n        ) \n    {\n        require(_playerIndex < games[_gameId].playerCount, \"Player index out of bounds\");\n        Player storage player = games[_gameId].players[_playerIndex];\n        return (\n            player.playerAddress,\n            player.name,\n            player.color,\n            player.position,\n            player.score\n        );\n    }\n    \n    /**\n     * @dev Get player's registration info\n     * @param _player The player's address\n     */\n    function getPlayerInfo(address _player) \n        external \n        view \n        returns (\n            bool isRegistered,\n            string memory name,\n            Color color,\n            uint256 totalScore\n        ) \n    {\n        return (\n            registeredPlayers[_player],\n            playerNames[_player],\n            playerColors[_player],\n            playerScores[_player]\n        );\n    }\n    \n  \n    function getTotalGames() external view returns (uint256) {\n        return gameCounter;\n    }\n    \n   \n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
      }
    }
  }
}